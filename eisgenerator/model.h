/* * eisgenerator - a shared libary and application to generate EIS spectra
 * Copyright (C) 2022-2024 Carl Philipp Klemm <carl@uvos.xyz>
 *
 * This file is part of eisgenerator.
 *
 * eisgenerator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * eisgenerator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with eisgenerator.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <complex>
#include <cstddef>
#include <string>
#include <vector>
#include <functional>

#include "eistype.h"
#include "componant/componant.h"

namespace eis
{

struct CompiledObject;

/**
* Eis modeling
* @defgroup MODELING Modeling
* @{
*/

/**
* @brief The main class of eisgenerator reprisenting a equivalent circuit model
*/
class Model
{
private:
	Componant *processBrackets(std::string& str, size_t& bracketCounter, size_t paramSweepCount, bool defaultToRange);
	Componant *processBracket(std::string& str, size_t paramSweepCount, bool defaultToRange);
	std::string getParamStr(const std::string& str, size_t index);
	static size_t paramSkipIndex(const std::string& str, size_t index);
	static void addComponantToFlat(Componant* componant, std::vector<Componant*>* flatComponants);

	static void sweepThreadFn(std::vector<std::vector<DataPoint>>* data, Model* model, size_t start, size_t stop, const Range& omega);

	size_t getActiveParameterCount();

private:
	Componant *_model = nullptr;
	std::vector<Componant*> _bracketComponants;
	std::string _modelStr;
	std::vector<Componant*> _flatComponants;
	std::string _modelUuid;
	CompiledObject* _compiledModel = nullptr;

public:

	/**
	* @brief Constructor
	*
	* @throws parse_errror
	* @param str the model string to create a model object for
	* @param paramSweepCount optionally the number of sweep point to use for parameter sweeps
	* @param defaultToRange optionally a bool that if true, circut elements not given in str are defaulted to a range instead of a fixed value
	*/
	Model(const std::string& str, size_t paramSweepCount = 100, bool defaultToRange = true);
	Model(const Model& in);
	Model& operator=(const Model& in);
	~Model();

	/**
	* @brief Ajusts the sweep count so that the total of spectra that need to be generated in the parameter sweep is close to the given value
	*
	* @param totalCount the total number of spectra to target
	* @return the number of spectra that will be generated by a parameter sweep after calling this function, should be close to, but may not be exactly totalCount
	*/
	size_t setParamSweepCountClosestTotal(size_t totalCount);

	/**
	* @brief Gets the impedance at the given frequency
	* this method calls resolveSteps
	*
	* @param omega the frequency in rad/s to calculate the impedance at
	* @param index an optional intex to the parameter sweep step at which to calculate the impedance
	* @return a DataPoint struct containing the result
	*/
	DataPoint execute(fvalue omaga, size_t index = 0);

	/**
	* @brief Executes a frequency sweep along the given range
	* this method calls resolveSteps
	*
	* @param omega the range along which to execute a frequency sweep
	* @param index an optional intex to the parameter sweep step at which to calculate the impedance
	* @return a vector of DataPoint structs containing the impedance at every frequency in the sweep
	*/
	std::vector<DataPoint> executeSweep(const Range& omega, size_t index = 0);

	/**
	* @brief Executes a frequency sweep with the given omega values
	*
	* @param omega a vector of frequencyies in rad/s to calculate the impedance at
	* @param index an optional intex to the parameter sweep step at which to calculate the impedance
	* @return a vector of DataPoint structs containing the impedance at every frequency in the sweep
	*/
	std::vector<DataPoint> executeSweep(const std::vector<fvalue>& omega, size_t index = 0);

	/**
	* @brief Executes a frequency sweep with the given omega values for eatch parameter combination in the applied parameter sweep
	* this method calls resolveSteps
	*
	* @param omega the range along which to execute a frequency sweep
	* @return a vector of vectors of DataPoint structs containing the impedance at every frequency in the sweep with every parameter combination
	*/
	std::vector<std::vector<DataPoint>> executeAllSweeps(const Range& omega);

	/**
	* @brief Returns the model string corrisponding to this model object, without embeded parameters
	*
	* @return the model string corrisponding to this model object, without embeded parameters
	*/
	std::string getModelStr() const;

	/**
	* @brief Returns the model string corrisponding to this model object, with embeded parameters
	* this method calls resolveSteps
	*
	* @param index the parameter sweep index for which to embed the parameters
	* @return the model string corrisponding to this model object, with embeded parameters
	*/
	std::string getModelStrWithParam(size_t index);

	/**
	* @brief Returns the model string corrisponding to this model object, with embeded parameters
	* the parameter sweep index of the last call to resolveSteps or 0 is used
	*
	* @return the model string corrisponding to this model object, with embeded parameters
	*/
	std::string getModelStrWithParam() const;

	/**
	* @brief Returns a uinique id that is unique for this circut, but not for this object specifically

	* @return the uid
	*/
	size_t getUuid();

	/**
	* @brief Returns a vector of pointers to the circuit elements in this model
	* the pointers can only be assumbed to be valid until the next member call to this model object
	*
	* @param model for internal use only
	* @return a vector of the circuit elements in the model
	*/
	std::vector<Componant*> getFlatComponants(Componant *model = nullptr);

	/**
	* @brief gets the values of the parameters of the circuit elements at the current parameter sweep step
	*
	* @return the values of the parameters of the circuit elements at the current parameter sweep step
	*/
	std::vector<fvalue> getFlatParameters();

	/**
	* @brief gets the ranges of the parameters of the circuit elements
	*
	* @return the ranges of the parameters of the circuit elements
	*/
	std::vector<Range> getFlatParameterRanges();

	/**
	* @brief gets the default ranges of the parameters of eatch type of circuit elemen used in the model
	*
	* @return the default ranges of the parameters of eatch type of circuit elemen used in the model
	*/
	std::vector<Range> getDefaultParameters();

	/**
	* @brief gets the total number of parameters used by all the circuit elements in this model
	*
	* @return the total number of parameters
	*/
	size_t getParameterCount();

	/**
	* @brief this function compiles the model into native vectorized code for faster execution
	*
	* This function compiles a shared-object for this model that is then loaded by eisgenerator to
	* speed up execution of this model by a factor of 10 or more by employing vectorization and avoiding
	* function calls.
	*
	* This function is slow, but results are cached for the lifetime of process linked to libeisgenerator
	* so that a circuit has to be compiled only once and can then be used by any number of Model objects.
	*
	* This function is only implemented on UNIX, on other platforms this function will allways return false.
	* This function also requires that gcc be availble in PATH.
	*
	* @return true if compile was sucessfull, false otherwise
	*/
	bool compile();

	/**
	* @brief this member determines if the model is in a state ready to execute
	*
	* @return true if the model is ready for the execute* family of methods
	*/
	bool isReady();

	/**
	* @brief this member resolves the parameters of all circuit elements at the given parameter sweep step
	*
	* @param index the index to the sweep step to resolve to
	*/
	void resolveSteps(int64_t index);

	/**
	* @brief gets the total number of parameter sweep steps for the applied sweep
	*
	* @return the total number of parameter sweep steps for the applied sweep
	*/
	size_t getRequiredStepsForSweeps();

	/**
	* @brief checks if the model is a sweep (ie has at least one paramter with a range)
	*
	* @return true if the model contains a parameter sweep, false otherwise
	*/
	bool isParamSweep();

	/**
	* @brief compiles this model into efficant c++ code corrisponding to the circuit of this model
	*
	* @return the code or an empty string if compilation was unsucessfull
	*/
	std::string getCode();

	/**
	* @brief compiles this model into TorchScript
	* to be compiled by torch::jit::compile
	*
	* @return the TorchScript code or an empty string if compilation was unsucessfull
	*/
	std::string getTorchScript();

	/**
	* @brief Gets the function name in the code for this model
	*
	* @return the function name in the code for this model
	*/
	std::string getCompiledFunctionName();

	/**
	* @brief Gets the function name in the code returned by getTorchScript and getCode for this model
	*
	* @return the function name in the code for this model
	*/
	std::vector<size_t> getRecommendedParamIndices(eis::Range omegaRange, double distance, bool threaded = false);
};

/**
 *  @example simple.cpp
 *  A simple example in how to use eisgenerator
 */

/**
 *  @example compileing.cpp
 *  An example on how to use the eisgenerator compiled execution model
 */

/**
 *  @example torchscript.cpp
 *  An example on how to use the eisgenerator torch execution model
 */

/** @} */

}
